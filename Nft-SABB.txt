https://github.com/BrettPitt/raspiiot/blob/6e88bc1589257a71bb4d61c0eb2d1fac43b25dc6/device/index.js
---------
https://dinochiesa.github.io/hmachash/index.html
https://github.com/ksgerastenok/datapower/blob/f5e258dc24e344e899e5f64eb53845e2eded166b/logger/log.header.xsl
https://github.com/ksgerastenok/datapower/blob/f5e258dc24e344e899e5f64eb53845e2eded166b/domain/functions.xsl
https://github.com/szesto/datapower-router/blob/72160b36cf14005e327f4df12821daa13e33638b/local/router/oauth-client-config.js
--------

// set authorization header
        hm.current.set('Authorization', 'Bearer ' + json.access_token);
        console.error(`${tr} bearer token azn header: ${hm.current.get('Authorization')}`);
	---------

<xsl:when test="((not(count(dp:parse(./text())) = 0)))">


<dp:serialize select="./*" omit-xml-decl="yes"/>


<!--dp:input-mapping href="local:///ffd/base-64.ffd" type="ffd"/-->


<xsl:when test="((dp:responding()))">

<xsl:value-of select="dp:variable('var://service/URL-in')"/>
<xsl:value-of select="dp:variable('var://service/URL-out')"/>
<dp:set-request-header name="./@name" value="./text()"/>

<xsl:element name="Body">
					<xsl:copy-of select="dp:binary-encode($vCALL/result/binary/node())"/>
				</xsl:element
---------=====

var hm = require('header-metadata');
var nxPrefix = 'man';
var nameSpaceSuffix = 'JSONTOSOAP'
var statuscode = hm.response.statusCode;
var statusdesc;

const nsPrefix = nxPrefix;
const nameSpace = "http://xgw.org.co.il/" + nameSpaceSuffix + "/";

if (statuscode == '200') {
    statuscode = '0';
    statusdesc = 'Success';

    session.input.readAsJSON(function (error, json) {
        if (error) {
            console.error('@@@AB Input is not valid JSON. ', error);
            session.output.write(error);
        } else {
            var prop = json.name;
            var output = '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:' + nxPrefix + '="http://www.w3.org/2001/XMLSchema">' +
                '<soapenv:Header />' +
                '<soapenv:Body>' +
                '<' + nsPrefix + ':' + 'Document_OUT xmlns:ns0="urn:Document_OUT" xmlns:ns1="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsi="http://www.w3.org/2001/XMLSchema">' +
                '<' + nsPrefix + ':name>' + prop + '</' + nsPrefix + ':name>' +
                '</' + nsPrefix + ':' + 'Document_OUT>' +
                '</soapenv:Body>' +
                '</soapenv:Envelope>';

            hm.current.set('Content-Type', 'text/xml');
            session.output.write(output);
        }
    })
} else {
    statuscode = '1';

    session.input.readAsJSON(function (error, json) {
        if (error) {
            console.error('Input is not valid JSON. ', error);
        } else {
            AnnotationID = 1;
            statusdesc = json["Message"];
            var output = '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" >' +
                '<soapenv:Header />' +
                '<soapenv:Body>' +
                '<' + nsPrefix + ':' + 'Document_OUT xmlns:ns0="urn:mg_iBOLT_FileNet_Methods_CreateAnnotation_Document_OUT" xmlns:ns1="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsi="http://www.w3.org/2001/XMLSchema">' +
                '<' + nsPrefix + ':StatusCode>' + statuscode + '</' + nsPrefix + ':StatusCode>' + '<' + nsPrefix + ':StatusDesc>' + statusdesc + '</' + nsPrefix + ':StatusDesc>' +
                '<' + nsPrefix + ':AnnotationID>' + AnnotationID + '</' + nsPrefix + ':AnnotationID>' +
                '</' + nsPrefix + ':' + 'Document_OUT>' +
                '</soapenv:Body>' +
                //'</soapenv:Body>' +// Added
                '</soapenv:Envelope>';

            hm.current.set('Content-Type', 'text/xml');
            session.output.write(output);
        }
    })
}

----------


/*
This Gateway Script to find book quantity. Name taken from URI
*/
var sm = require('service-metadata'), hm = require('header-metadata'), urlopen = require('urlopen');
var uri = sm.getVar('var://service/URI');
var uriSplit = uri.split("/");
var bookName = uriSplit[1];
function getBook(books, bookName) {
for (var i = 0; i < books.length; i++) {
if (books[i]['name'] == bookName) {
return books[i]
}
}
return null;
}
function getTimeStamp() {
var d = new Date();
return d.toISOString();
}
console.debug("Getting Book Quantity for bookName = " + bookName);
urlopen.open("local:///books.json", function(error, response) {
if (error) {
console.debug("urlopen error: " + JSON.stringify(error));
} else {
console.debug("urlopen response.statusCode = " + response.statusCode);
response.readAsJSON(function(error, books) {
if (error) {
session.output.write("readAsJSSON error: "
+ JSON.stringify(error));
} else {
var book = getBook(books['books'], bookName);
if (book) {
var bookQuantity = {};
bookQuantity.book = book['name'];
bookQuantity.quantity = book['quantity'];
bookQuantity.dateTime = getTimeStamp();
session.output.write(JSON.stringify(bookQuantity, null, '\t'));
}

-----------

Calculate signature( Signature) AccessKey,: SecretKey123456789,: 123456789 ::

    SecretKey = "123456789"
    StringToSign = "1497508720\nbce2029159576daffb8574ae670697bbbb186281"
    Signature = HexEncode(HmacSHA1(StringToSign,SecretKey))
              = "e750db371d068d16b36422a6f36bd177daf1c2aa"
			  
			  
Generate signature string::			  
			  Generate signature string::
    Authorization = Base64("HMAC-SHA1 123456789:e750db371d068d16b36422a6f36bd177daf1c2aa")
                  = "SE1BQy1TSEExIDEyMzQ1Njc4OTplNzUwZGIzNzFkMDY4ZDE2YjM2NDIyYTZmMzZiZDE3N2RhZjFjMmFh"

Complete request message::
POST /v1/print/ HTTP/1.1
    Host: api.sonma.net
    Authorization: SE1BQy1TSEExIDEyMzQ1Njc4OTplNzUwZGIzNzFkMDY4ZDE2YjM2NDIyYTZmMzZiZDE3N2RhZjFjMmFh
    Timestamp: 1497508720
    Cache-Control: no-cache
    Content-Type: application/x-www-form-urlencoded

    content=~~~%20%21%21%21%2B%2B%2B%2A%26%5E%25%24%23%40%3F%2F_&sn=123456789

-------
var crypto = require('crypto');
var key = "Alice";

var hmac = crypto.createHmac('hmac-sha256', key);
var input = "This is plaintext to hash";
var result = hmac.update(input).digest('base64');

session.output.write(result);
===========
Signature calculation pseudo code


    Authorization = Base64(HMAC-SHA1 + 空格 + AccessKey+ : + Signature)
 
    Signature = HexEncode(HmacSHA1(StringToSign,SecretKey))

    StringToSign  = Timestamp + '\n' + HashedCanonicalQueryString

    HashedCanonicalQueryString = HexEncode(Hash(CanonicalQueryString)
=======

var crypto = require('crypto');
var key = "Alice";

var hmac = crypto.createHmac('hmac-sha256', key);
var input = "This is plaintext to hash";
var result = hmac.update(input).digest('base64');

session.output.write(result);
-----------

var date = new Date()

var utcDate = date.toUTCString()



https://www.ibm.com/docs/en/datapower-gateways/2018.4?

topic=methods-crypto-module#crypto.createHash


<xsl:variable name="sha-hash" select="dp:hash($SHA1, $plainText)"/>


 base-16 encoding of the digest 

The hash length is the length of the hash function output in bytes. 

Note that the resulting hash is encoded with Base 64, so the digest 

HexEncode represents a function that returns the base-16 encoding 

of the digest in lowercase characters. 


Implementers should be aware that base16 digests are case 

insensitive. 


the MD5 hash output is 16 bytes

-----------

var crypto = require('crypto');
var key = "Alice";

var sign = crypto.createSign('rsa-sha256');
sign.update('This is text to sign').sign(key, function(error, signature) {
  if (error) {
    console.error("sign error "+error);
  } else {
    console.log("signature with rsa-sha256 is "+signature.toString('base64'));
    session.output.write(signature);
  }
});

----------

const crypto = require('crypto');
const hmac = crypto.createHmac('sha256', 'a secret');

hmac.update('some data to hash');
console.log(hmac.digest('hex'));
// Prints:
//   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e

---

const crypto = require('crypto');
const hmac = crypto.createHmac('sha256', 'a secret');

hmac.on('readable', () => {
  const data = hmac.read();
  if (data) {
    console.log(data.toString('hex'));
    // Prints:
    //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
  }
});

hmac.write('some data to hash');
hmac.end();
-------
const crypto = require('crypto');
const sign = crypto.createSign('SHA256');

sign.update('some data to sign');

const privateKey = getPrivateKeySomehow();
console.log(sign.sign(privateKey, 'hex'));
// Prints: the calculated signature
----------
const crypto = require('crypto');
const hash = crypto.createHash('sha256');

hash.update('some data to hash');
console.log(hash.digest('hex'));
// Prints:
//   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50

--------
	 [ hash.update()][] and [ hash.digest()][] methods to generate the calculated hash.
	
----
// user=cpet
// AWS_ACCESS_KEY_ID : "AKIAI5KH46DEYEGVNFNA"
// AWS_SECRET_ACCESS_KEY : "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"

// user=opc
// AWS_ACCESS_KEY_ID : "AKIAIN754R7GFVCTI76Q"
// AWS_SECRET_ACCESS_KEY : "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"

// AWS parameters used to create a new RequestSigner
var aws_params = {
    AWS_S3_HOST : "s3.amazonaws.com",
	AWS_ACCESS_KEY_ID : "AKIAI5KH46DEYEGVNFNA",
	AWS_SECRET_ACCESS_KEY : "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",
	AWS_REGION : "us-east-1",
	AWS_SERVICE : "s3",
	AWS4_DEBUG : true
};

var signer = new aws4.RequestSigner(aws_params);

var _url = new URL(request.url.trim()
    .replace("{{API_HOST}}", aws_params["AWS_S3_HOST"])
);

// Create read-only object containing the request context
var context = {
	API_HOST : _url.hostname,
	BUCKET_NAME : _url.hostname.split('.')[0]
};

var _request = {
	method : request.method,
	url : _url,
	headers : request.headers,
	data : request.data,
	dataMode : request.dataMode
};

var atz_header = signer.sign(context, _request);

// Set POSTMAN environment variables associated with url
postman.setEnvironmentVariable('BUCKET_NAME', context["BUCKET_NAME"]);
postman.setEnvironmentVariable('API_HOST', aws_params["AWS_S3_HOST"]);

// Set POSTMAN environment variables associate with headers
postman.setEnvironmentVariable("AUTHORIZATION_HEADER", atz_header);
postman.setEnvironmentVariable('DATE_HEADER', signer.headers["DATE"]);

// Set POSTMAN environment variables associate with additional headers
postman.setEnvironmentVariable("X_AMZ_DATE_HEADER", signer.headers["X_AMZ_DATE"]);
postman.setEnvironmentVariable('X_CONTENT_SHA256_HEADER', signer.headers["X_CONTENT_SHA256"]);

console.log(aws_params["AWS4_CANONICAL_REQUEST"]);
console.log(aws_params["Calculate signature( Signature) AccessKey,: SecretKey123456789,: 123456789 ::

    SecretKey = "123456789"
    StringToSign = "1497508720\nbce2029159576daffb8574ae670697bbbb186281"
    Signature = HexEncode(HmacSHA1(StringToSign,SecretKey))
              = "e750db371d068d16b36422a6f36bd177daf1c2aa""]);
